"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/questionnaire/page",{

/***/ "(app-pages-browser)/./lib/gemini.ts":
/*!***********************!*\
  !*** ./lib/gemini.ts ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateRecommendations: function() { return /* binding */ generateRecommendations; }\n/* harmony export */ });\n/* harmony import */ var _google_generative_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @google/generative-ai */ \"(app-pages-browser)/./node_modules/@google/generative-ai/dist/index.mjs\");\n\nconst genAI = new _google_generative_ai__WEBPACK_IMPORTED_MODULE_0__.GoogleGenerativeAI(\"AIzaSyATy2lW3kQ0LeBVi7S5ZNoAdlUL-ZYJaY0\" || 0);\nconst generateRecommendations = async function(preferences, watchHistory) {\n    let surpriseMe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    try {\n        const model = genAI.getGenerativeModel({\n            model: \"gemini-1.5-flash\"\n        });\n        const prompt = buildPrompt(preferences, watchHistory, surpriseMe);\n        const result = await model.generateContent(prompt);\n        const response = await result.response;\n        const text = response.text();\n        // Parse the JSON response\n        const parsedResponse = JSON.parse(text);\n        return parsedResponse.recommendations || [];\n    } catch (error) {\n        console.error(\"Error generating recommendations:\", error);\n        throw new Error(\"Failed to generate recommendations. Please try again.\");\n    }\n};\nconst buildPrompt = (preferences, watchHistory, surpriseMe)=>{\n    const watchHistoryText = watchHistory.length > 0 ? \"\\n\\nWatch History (with ratings):\\n\".concat(watchHistory.map((movie)=>\"- \".concat(movie.title, \" (\").concat(movie.year, \") - Rating: \").concat(movie.rating, \"/10\")).join(\"\\n\")) : \"\\n\\nNo watch history available.\";\n    const surpriseMeText = surpriseMe ? \"\\n\\nIMPORTANT: The user wants to be surprised! Ignore some of their preferences and suggest unexpected but great movies that might expand their horizons.\" : \"\";\n    return \"You are an expert movie recommendation AI. Based on the user's preferences and watch history, suggest 8-10 movies that match their taste.\\n\\nUser Preferences:\\n- Favorite Genres: \".concat(preferences.genres.join(\", \"), \"\\n- Preferred Era: \").concat(preferences.era, \"\\n- Mood/Tone: \").concat(preferences.mood.join(\", \"), \"\\n- Content Level: \").concat(preferences.contentLevel, \"\\n- Watch Time: \").concat(preferences.watchTime, \"\\n- Rating Preference: \").concat(preferences.ratingPreference, \"\\n- Score Preference: \").concat(preferences.scorePreference).concat(watchHistoryText).concat(surpriseMeText, '\\n\\nPlease respond with a JSON object in this exact format:\\n{\\n  \"recommendations\": [\\n    {\\n      \"title\": \"Movie Title\",\\n      \"year\": 2023,\\n      \"genre\": [\"Action\", \"Thriller\"],\\n      \"description\": \"Brief plot description (2-3 sentences)\",\\n      \"reasoning\": \"Why this movie matches their preferences (1-2 sentences)\"\\n    }\\n  ]\\n}\\n\\nGuidelines:\\n- Include a mix of well-known and hidden gems\\n- Consider the user\\'s rating preferences (highly-rated vs hidden gems)\\n- Balance their genre preferences with their mood and content preferences\\n- If they have watch history, consider patterns in their ratings\\n- For surprise recommendations, suggest movies that are excellent but might not perfectly match their stated preferences\\n- Ensure all movies are real and available\\n- Provide diverse recommendations within their preferences\\n- Make reasoning specific and helpful\\n\\nReturn only the JSON object, no additional text.');\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9nZW1pbmkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkQ7QUFHM0QsTUFBTUMsUUFBUSxJQUFJRCxxRUFBa0JBLENBQUNFLHlDQUFzQyxJQUFJO0FBRXhFLE1BQU1HLDBCQUEwQixlQUNyQ0MsYUFDQUM7UUFDQUMsOEVBQXNCO0lBRXRCLElBQUk7UUFDRixNQUFNQyxRQUFRUixNQUFNUyxrQkFBa0IsQ0FBQztZQUFFRCxPQUFPO1FBQW1CO1FBRW5FLE1BQU1FLFNBQVNDLFlBQVlOLGFBQWFDLGNBQWNDO1FBQ3RELE1BQU1LLFNBQVMsTUFBTUosTUFBTUssZUFBZSxDQUFDSDtRQUMzQyxNQUFNSSxXQUFXLE1BQU1GLE9BQU9FLFFBQVE7UUFDdEMsTUFBTUMsT0FBT0QsU0FBU0MsSUFBSTtRQUUxQiwwQkFBMEI7UUFDMUIsTUFBTUMsaUJBQWlDQyxLQUFLQyxLQUFLLENBQUNIO1FBQ2xELE9BQU9DLGVBQWVHLGVBQWUsSUFBSSxFQUFFO0lBQzdDLEVBQUUsT0FBT0MsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMscUNBQXFDQTtRQUNuRCxNQUFNLElBQUlFLE1BQU07SUFDbEI7QUFDRixFQUFFO0FBRUYsTUFBTVgsY0FBYyxDQUNsQk4sYUFDQUMsY0FDQUM7SUFFQSxNQUFNZ0IsbUJBQW1CakIsYUFBYWtCLE1BQU0sR0FBRyxJQUMzQyxzQ0FFYSxPQUZ5QmxCLGFBQWFtQixHQUFHLENBQUNDLENBQUFBLFFBQ3JELEtBQXFCQSxPQUFoQkEsTUFBTUMsS0FBSyxFQUFDLE1BQTZCRCxPQUF6QkEsTUFBTUUsSUFBSSxFQUFDLGdCQUEyQixPQUFiRixNQUFNRyxNQUFNLEVBQUMsUUFDM0RDLElBQUksQ0FBQyxTQUNQO0lBRUosTUFBTUMsaUJBQWlCeEIsYUFDbkIsOEpBQ0E7SUFFSixPQUFPLHNMQUlVRixPQURFQSxZQUFZMkIsTUFBTSxDQUFDRixJQUFJLENBQUMsT0FBTSx1QkFFcEN6QixPQURJQSxZQUFZNEIsR0FBRyxFQUFDLG1CQUVoQjVCLE9BREpBLFlBQVk2QixJQUFJLENBQUNKLElBQUksQ0FBQyxPQUFNLHVCQUUzQnpCLE9BREdBLFlBQVk4QixZQUFZLEVBQUMsb0JBRXJCOUIsT0FEUEEsWUFBWStCLFNBQVMsRUFBQywyQkFFaEIvQixPQURDQSxZQUFZZ0MsZ0JBQWdCLEVBQUMsMEJBQ0FkLE9BQTlCbEIsWUFBWWlDLGVBQWUsRUFBc0JQLE9BQW5CUixrQkFBa0MsT0FBZlEsZ0JBQWU7QUEwQnRGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9nZW1pbmkudHM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHb29nbGVHZW5lcmF0aXZlQUkgfSBmcm9tICdAZ29vZ2xlL2dlbmVyYXRpdmUtYWknO1xuaW1wb3J0IHsgVXNlclByZWZlcmVuY2VzLCBXYXRjaGVkTW92aWUsIFJlY29tbWVuZGF0aW9uLCBHZW1pbmlSZXNwb25zZSB9IGZyb20gJ0AvdHlwZXMnO1xuXG5jb25zdCBnZW5BSSA9IG5ldyBHb29nbGVHZW5lcmF0aXZlQUkocHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR0VNSU5JX0FQSV9LRVkgfHwgJycpO1xuXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMgPSBhc3luYyAoXG4gIHByZWZlcmVuY2VzOiBVc2VyUHJlZmVyZW5jZXMsXG4gIHdhdGNoSGlzdG9yeTogV2F0Y2hlZE1vdmllW10sXG4gIHN1cnByaXNlTWU6IGJvb2xlYW4gPSBmYWxzZVxuKTogUHJvbWlzZTxSZWNvbW1lbmRhdGlvbltdPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgbW9kZWwgPSBnZW5BSS5nZXRHZW5lcmF0aXZlTW9kZWwoeyBtb2RlbDogJ2dlbWluaS0xLjUtZmxhc2gnIH0pO1xuXG4gICAgY29uc3QgcHJvbXB0ID0gYnVpbGRQcm9tcHQocHJlZmVyZW5jZXMsIHdhdGNoSGlzdG9yeSwgc3VycHJpc2VNZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9kZWwuZ2VuZXJhdGVDb250ZW50KHByb21wdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXN1bHQucmVzcG9uc2U7XG4gICAgY29uc3QgdGV4dCA9IHJlc3BvbnNlLnRleHQoKTtcblxuICAgIC8vIFBhcnNlIHRoZSBKU09OIHJlc3BvbnNlXG4gICAgY29uc3QgcGFyc2VkUmVzcG9uc2U6IEdlbWluaVJlc3BvbnNlID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VkUmVzcG9uc2UucmVjb21tZW5kYXRpb25zIHx8IFtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgcmVjb21tZW5kYXRpb25zOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSByZWNvbW1lbmRhdGlvbnMuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gIH1cbn07XG5cbmNvbnN0IGJ1aWxkUHJvbXB0ID0gKFxuICBwcmVmZXJlbmNlczogVXNlclByZWZlcmVuY2VzLFxuICB3YXRjaEhpc3Rvcnk6IFdhdGNoZWRNb3ZpZVtdLFxuICBzdXJwcmlzZU1lOiBib29sZWFuXG4pOiBzdHJpbmcgPT4ge1xuICBjb25zdCB3YXRjaEhpc3RvcnlUZXh0ID0gd2F0Y2hIaXN0b3J5Lmxlbmd0aCA+IDAgXG4gICAgPyBgXFxuXFxuV2F0Y2ggSGlzdG9yeSAod2l0aCByYXRpbmdzKTpcXG4ke3dhdGNoSGlzdG9yeS5tYXAobW92aWUgPT4gXG4gICAgICAgIGAtICR7bW92aWUudGl0bGV9ICgke21vdmllLnllYXJ9KSAtIFJhdGluZzogJHttb3ZpZS5yYXRpbmd9LzEwYFxuICAgICAgKS5qb2luKCdcXG4nKX1gXG4gICAgOiAnXFxuXFxuTm8gd2F0Y2ggaGlzdG9yeSBhdmFpbGFibGUuJztcblxuICBjb25zdCBzdXJwcmlzZU1lVGV4dCA9IHN1cnByaXNlTWUgXG4gICAgPyAnXFxuXFxuSU1QT1JUQU5UOiBUaGUgdXNlciB3YW50cyB0byBiZSBzdXJwcmlzZWQhIElnbm9yZSBzb21lIG9mIHRoZWlyIHByZWZlcmVuY2VzIGFuZCBzdWdnZXN0IHVuZXhwZWN0ZWQgYnV0IGdyZWF0IG1vdmllcyB0aGF0IG1pZ2h0IGV4cGFuZCB0aGVpciBob3Jpem9ucy4nXG4gICAgOiAnJztcblxuICByZXR1cm4gYFlvdSBhcmUgYW4gZXhwZXJ0IG1vdmllIHJlY29tbWVuZGF0aW9uIEFJLiBCYXNlZCBvbiB0aGUgdXNlcidzIHByZWZlcmVuY2VzIGFuZCB3YXRjaCBoaXN0b3J5LCBzdWdnZXN0IDgtMTAgbW92aWVzIHRoYXQgbWF0Y2ggdGhlaXIgdGFzdGUuXG5cblVzZXIgUHJlZmVyZW5jZXM6XG4tIEZhdm9yaXRlIEdlbnJlczogJHtwcmVmZXJlbmNlcy5nZW5yZXMuam9pbignLCAnKX1cbi0gUHJlZmVycmVkIEVyYTogJHtwcmVmZXJlbmNlcy5lcmF9XG4tIE1vb2QvVG9uZTogJHtwcmVmZXJlbmNlcy5tb29kLmpvaW4oJywgJyl9XG4tIENvbnRlbnQgTGV2ZWw6ICR7cHJlZmVyZW5jZXMuY29udGVudExldmVsfVxuLSBXYXRjaCBUaW1lOiAke3ByZWZlcmVuY2VzLndhdGNoVGltZX1cbi0gUmF0aW5nIFByZWZlcmVuY2U6ICR7cHJlZmVyZW5jZXMucmF0aW5nUHJlZmVyZW5jZX1cbi0gU2NvcmUgUHJlZmVyZW5jZTogJHtwcmVmZXJlbmNlcy5zY29yZVByZWZlcmVuY2V9JHt3YXRjaEhpc3RvcnlUZXh0fSR7c3VycHJpc2VNZVRleHR9XG5cblBsZWFzZSByZXNwb25kIHdpdGggYSBKU09OIG9iamVjdCBpbiB0aGlzIGV4YWN0IGZvcm1hdDpcbntcbiAgXCJyZWNvbW1lbmRhdGlvbnNcIjogW1xuICAgIHtcbiAgICAgIFwidGl0bGVcIjogXCJNb3ZpZSBUaXRsZVwiLFxuICAgICAgXCJ5ZWFyXCI6IDIwMjMsXG4gICAgICBcImdlbnJlXCI6IFtcIkFjdGlvblwiLCBcIlRocmlsbGVyXCJdLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkJyaWVmIHBsb3QgZGVzY3JpcHRpb24gKDItMyBzZW50ZW5jZXMpXCIsXG4gICAgICBcInJlYXNvbmluZ1wiOiBcIldoeSB0aGlzIG1vdmllIG1hdGNoZXMgdGhlaXIgcHJlZmVyZW5jZXMgKDEtMiBzZW50ZW5jZXMpXCJcbiAgICB9XG4gIF1cbn1cblxuR3VpZGVsaW5lczpcbi0gSW5jbHVkZSBhIG1peCBvZiB3ZWxsLWtub3duIGFuZCBoaWRkZW4gZ2Vtc1xuLSBDb25zaWRlciB0aGUgdXNlcidzIHJhdGluZyBwcmVmZXJlbmNlcyAoaGlnaGx5LXJhdGVkIHZzIGhpZGRlbiBnZW1zKVxuLSBCYWxhbmNlIHRoZWlyIGdlbnJlIHByZWZlcmVuY2VzIHdpdGggdGhlaXIgbW9vZCBhbmQgY29udGVudCBwcmVmZXJlbmNlc1xuLSBJZiB0aGV5IGhhdmUgd2F0Y2ggaGlzdG9yeSwgY29uc2lkZXIgcGF0dGVybnMgaW4gdGhlaXIgcmF0aW5nc1xuLSBGb3Igc3VycHJpc2UgcmVjb21tZW5kYXRpb25zLCBzdWdnZXN0IG1vdmllcyB0aGF0IGFyZSBleGNlbGxlbnQgYnV0IG1pZ2h0IG5vdCBwZXJmZWN0bHkgbWF0Y2ggdGhlaXIgc3RhdGVkIHByZWZlcmVuY2VzXG4tIEVuc3VyZSBhbGwgbW92aWVzIGFyZSByZWFsIGFuZCBhdmFpbGFibGVcbi0gUHJvdmlkZSBkaXZlcnNlIHJlY29tbWVuZGF0aW9ucyB3aXRoaW4gdGhlaXIgcHJlZmVyZW5jZXNcbi0gTWFrZSByZWFzb25pbmcgc3BlY2lmaWMgYW5kIGhlbHBmdWxcblxuUmV0dXJuIG9ubHkgdGhlIEpTT04gb2JqZWN0LCBubyBhZGRpdGlvbmFsIHRleHQuYDtcbn07XG4iXSwibmFtZXMiOlsiR29vZ2xlR2VuZXJhdGl2ZUFJIiwiZ2VuQUkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfR0VNSU5JX0FQSV9LRVkiLCJnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyIsInByZWZlcmVuY2VzIiwid2F0Y2hIaXN0b3J5Iiwic3VycHJpc2VNZSIsIm1vZGVsIiwiZ2V0R2VuZXJhdGl2ZU1vZGVsIiwicHJvbXB0IiwiYnVpbGRQcm9tcHQiLCJyZXN1bHQiLCJnZW5lcmF0ZUNvbnRlbnQiLCJyZXNwb25zZSIsInRleHQiLCJwYXJzZWRSZXNwb25zZSIsIkpTT04iLCJwYXJzZSIsInJlY29tbWVuZGF0aW9ucyIsImVycm9yIiwiY29uc29sZSIsIkVycm9yIiwid2F0Y2hIaXN0b3J5VGV4dCIsImxlbmd0aCIsIm1hcCIsIm1vdmllIiwidGl0bGUiLCJ5ZWFyIiwicmF0aW5nIiwiam9pbiIsInN1cnByaXNlTWVUZXh0IiwiZ2VucmVzIiwiZXJhIiwibW9vZCIsImNvbnRlbnRMZXZlbCIsIndhdGNoVGltZSIsInJhdGluZ1ByZWZlcmVuY2UiLCJzY29yZVByZWZlcmVuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/gemini.ts\n"));

/***/ })

});